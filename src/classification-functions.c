/*
 * classification-functions.c
 * Author: Loredana Sandu
 * Description: Functions to classificate cones in the 2D plane and the 3D space.
 */

#include "classification-functions.h"


/* classification2d: Classifies a 2-dimensional cone generated by given vectors.

Input:
    unsigned int n: number of given vectors.
    double * v[n]: list of 3-dimensional given vectors.
    double * u: vector orthogonal to all given vectors.
    unsigned int vmin[]: list of integers initially empty.
    unsigned int * len_vmin: current length of vmin[].
    
Output:
    0 if cone is {0}.
    1 if cone is a ray.
    2 if cone is a line.
    3 if cone is a plane angle.
    4 if cone is a half-plane.
    5 if cone is a plane.
    10 if the cone couldn't be classified.
    vmin[] will contain the indexes of the vectors v_i that form the minimal generating set of vectors.
*/
unsigned int classification2d(unsigned int n, double * v[n], double * u, unsigned int vmin[], unsigned int * len_vmin)
{
    unsigned int i, j, right = 0, left = 1;
    double angles[n][n];
    double anglemax = angle(u, v[0], v[1]);
    *len_vmin = 0;

    if (n == 0){        // There are no generator vectors, cone is {0}.
        return 0;
    } else if (n == 1){         // Cone is a ray generated by a single vector.
        vmin[*len_vmin] = 0;
        *len_vmin = (*len_vmin) + 1;
        return 1;
    }


    /* Calculate angles between pairs of vectors, and the maximum angle */

    for (i=0; i<n; i++){
        for (j=0; j<n; j++){
            angles[i][j] = angle(u, v[i], v[j]);
            if (angles[i][j] > anglemax){
                right = i;
                left = j;
                anglemax = angles[i][j];
            }
        }
    }


    /* Classify cone and compute the set of minimal generating vectors. 
       Note that 0 <= anglemax <= pi */

    // If anglemax = 0, then cone is a ray generated by one of the given vectors.
    if (fabs(anglemax) < EPSILON){
        vmin[*len_vmin] = 0;
        *len_vmin = (*len_vmin) + 1;
        return 1;
    }

    // If 0 < anglemax <= pi, then v[right] i v[left] are the minimal generating vectors.
    vmin[*len_vmin] = right;
    *len_vmin = (*len_vmin) + 1;
    vmin[*len_vmin] = left;
    *len_vmin = (*len_vmin) + 1;

    // If 0 < anglemax < pi, the cone's either a plane angle with minimal generators v[right] and v[left], 
    // or it's a plane generated by v[right], v[left] and another vector with negative angle.
    if (fabs(anglemax - PI) > EPSILON){
        for (i=0; i<n; i++){
            if (angles[right][i] < 0){
                vmin[*len_vmin] = i;
                *len_vmin = (*len_vmin) + 1;
                return 5;
            }
        }
        return 3;
    }


    // If program arrived here, anglemax = pi, and then cone's either a line generated by v[right] and v[left] (all angles in {0,pi}), 
    // or it's a half-plane (all angles at the same side of v[right] i v[left]), 
    // or it's a plane.

    unsigned int line = 1, halfplane_neg = 0, halfplane_pos = 0;       // I use boolean values 0 (false) and 1 (true).

    for (i=0; i<n; i++){
        if (fabs(angles[right][i])>EPSILON && fabs(angles[right][i]-PI)>EPSILON){
            line = 0;
            if (angles[right][i] > 0){
                halfplane_pos = 1;
                if (*len_vmin == 2 || (*len_vmin == 3 && angles[right][vmin[2]] < 0)){
                    vmin[*len_vmin] = i;
                    *len_vmin = (*len_vmin) + 1;
                }
            }
            if (angles[right][i] < 0){
                halfplane_neg = 1;
                if (*len_vmin == 2 || (*len_vmin == 3 && angles[right][vmin[2]] > 0)){
                    vmin[*len_vmin] = i;
                    *len_vmin = (*len_vmin) + 1;
                }
            }
        }
    }

    if (line == 1){
        return 2;
    } else if (halfplane_pos == 1 && halfplane_neg == 1){
        return 5;
    } else if (halfplane_pos == 1 || halfplane_neg == 1){
        return 4;
    } else {
        return 10;       // If the cone couldn't be classified.
    }
}



unsigned int projectcone(unsigned int n, double * proj[n], double * u, double * v[n])
{
    /* Given a list of vectors v_i and a vector u not null,computes the list of not null 
    vectors which are the projection of v_i orthogonal to u. Returns the number of vectors
    with projection not null. */

    unsigned int len_proj = 0, i;
    double cos;

    for (i=0; i<n; i++){
        cos = dotproduct(u,v[i]) / (norm(u) * norm(v[i]));           // La projecció només serà afegida a la llista si el cos de l'angle entre u i v_i no és 1 ni -1, i.e. la projecció no és nul·la.
        if (fabs(cos-1) > EPSILON && fabs(cos+1) > EPSILON){
            projection(proj[len_proj], u, v[i]);
            len_proj++;
        }
    }

    return len_proj;
}


/* classification3d: Classifies a 3-dimensional cone generated by given vectors.

Input:
    unsigned int n: number of given vectors.
    double * v[n]: list of 3-dimensional given vectors.
    unsigned int vmin[]: list of integers initially empty.
    unsigned int * len_vmin: current length of vmin[].
    
Output:
    0 if cone is {0}.
    1 if cone is a ray.
    2 if cone is a line.
    3 if cone is a plane angle.
    4 if cone is a half-plane.
    5 if cone is a plane.
    6 if cone is a polyhedral cone.
    7 if cone is a solid dihedral angle.
    8 if cone is a half-space.
    9 if cone is the space.
    10 if the cone couldn't be classified.
    vmin[] will contain the indexes of the vectors v_i that form the minimal generating set of vectors.
*/
unsigned int classification3d(unsigned int n, double * v[n], unsigned int vmin[], unsigned int * len_vmin)
{
    unsigned int i, j, m, type2d, repeated;

    double * w[n];       // Array of pointers to a list of m <= n vectors.
    for (i=0; i<n; i++){
        w[i] = malloc(LEN * sizeof(double));
        if (w[i] == NULL){
            printf("\nError: couldn't reserve memory for vector w_%d\n", i+1);
            return 10;
        }
    }

    unsigned int wmin[4];       // List of <= 4 vectors
    unsigned int len_wmin = 0;

    unsigned int vfaces[n-1];   // List of <= n-1 vectors
    unsigned int len_vfaces = 0;

    double orth[LEN];      // Will contain the orthogonal vector.


    /* Separate the cases of dimension <= 1 */

    if (n == 0){            // Cone {0}
        return 0;
    } else if (n == 1){     // Ray
        vmin[*len_vmin] = 0;
        *len_vmin = (*len_vmin) + 1;
        return 1;
    }

    // If arrived here, n > 1. We project orthogonally with respect to any generating vector (e.g. v_1) and save the
    // projection to w and its size to m. If all projected vectors are null, then the dimension of the cone is 1.
    m = projectcone(n,w,v[0],v);
    if (m == 0){
        for (i=0; i<n; i++){
            if (dotproduct(v[0], v[i]) < 0){     // There's some pi angle, cone's a line.
                vmin[*len_vmin] = 0;
                *len_vmin = (*len_vmin) + 1;
                vmin[*len_vmin] = i;
                *len_vmin = (*len_vmin) + 1;
                return 2;
            }
        }
        vmin[*len_vmin] = 0;       // No pi angle, cone's a ray.
        *len_vmin = (*len_vmin) + 1;
        return 1;
    }


    /* Separate the cases of dimension 2 */

    // If arrived here, m > 0. If the projection has dimension 1, Then the cone has dimension 2.
    type2d = classification2d(m,w,v[0],wmin,&len_wmin);
    if (type2d < 3){
        crossproduct(orth,v[0],w[0]);   // orth: vector orthogonal to cone
        return classification2d(n,v,orth,vmin,len_vmin);
    }


    /* Classify the cases of dimension 3 */

    // Search edges: with respect to each v_i, compute the projection, and if it's a plane angle, then v_i is in an edge.
    // All v_i in edges are minimal generating vectors. Also, make a list of vectors on faces.
    for (i=0; i<n; i++){
        m = projectcone(n,w,v[i],v);
        type2d = classification2d(m,w,v[i],wmin,&len_wmin);
        if (type2d == 3){
            repeated = 0;    // Control that edge isn't repeated. Variable with boolean values.
            double cos;
            for (j=0; j<(*len_vmin); j++){
                cos = dotproduct(v[i],v[vmin[j]]) / (norm(v[i]) * norm(v[vmin[j]]));     // If cos = 1, then angle 0.
                if (fabs(cos - 1) < EPSILON){
                    repeated = 1;
                }
            }
            if (repeated == 0){
                vmin[*len_vmin] = i;
                *len_vmin = (*len_vmin) + 1;
            }
        }
        if (type2d == 4){
            vfaces[len_vfaces] = i;
            len_vfaces++;
        }
    }

    if (*len_vmin > 2){             // Polyhedral cone, we already have the set of minimal generating vectors.
        return 6;
    } else if (*len_vmin == 2){     // Solid dihedral angle, we have to find a vector on each face. Projections onto the edge must have an angle not null.
        for (i=0; i<LEN; i++){      // Do orth = v[vmin[0]]
            orth[i] = v[vmin[0]][i];
        }
        vmin[*len_vmin] = vfaces[0];
        *len_vmin = (*len_vmin) + 1;
        projection(w[0],orth,v[vfaces[0]]);   // Save in w[0] the projection of the first vector of vfaces onto the edge.
        double cos;
        for (i=1; i<len_vfaces; i++){
            projection(w[1],orth,v[vfaces[i]]);
            cos = dotproduct(w[0],w[1]) / (norm(w[0]) * norm(w[1]));      // If cos != 1, then angle != 0.
            if (fabs(cos - 1) > EPSILON){
                vmin[*len_vmin] = vfaces[i];
                *len_vmin = (*len_vmin) + 1;
                return 7;
            }
        }
    }

    // If arrived here, there are no edges, and the cone's either a half-space (if there are any vectors on a face) or the space.

    unsigned int len_w = 0;    // We need to empty w i know its length.
    if (len_vfaces > 0){
        j = n-1;
        double cos;
        for (i=0; i<len_vfaces; i++){
            w[len_w] = v[vfaces[i]];           // Save vectors on faces to search for minimal generating vectors.
            len_w++;
            cos = dotproduct(w[0],w[i]) / (norm(w[0]) * norm(w[i]));      // If cos not 1 nor -1, then angle not 0 nor pi.
            if (fabs(cos - 1) > EPSILON && fabs(cos + 1) > EPSILON){
                crossproduct(orth,w[0],w[i]);      // We need an orthogonal vector not null (that's why angle can't be 0 or pi).
            }
            if (j == n-1 && vfaces[i]>i){
                j = i;      // First i that isn't in vfaces will be the interior vector.
            }
        }
        type2d = classification2d(len_w,w,orth,wmin,&len_wmin);
        for(i=0; i<len_wmin; i++){
            vmin[*len_vmin] = vfaces[i];
            *len_vmin = (*len_vmin) + 1;
        }
        vmin[*len_vmin] = j;
        *len_vmin = (*len_vmin) + 1;
        return 8;
    }

    // If arrived here, cone's the space. We seek the set of minimal generating vectors using recursivity and checking which ones can be removed.
    for (i=1; i<n; i++){
        w[len_w] = v[i];   // Add to w all the v, but not v[0].
        len_w++;
    }
    i=0;
    while (classification3d(n-1,w,vmin,len_vmin) < 9){  // v[i] needed in the set of minimal generating vectors.
        w[i] = v[i];                            // Now don't include v[i+1].
        i++;
        if (i == n){                            // All v_i necessary.
            vmin[*len_vmin] = n-1;
            *len_vmin = (*len_vmin) + 1;
            return 9;
        }
        *len_vmin = 0;      // Empty vmin to call classification3d again.
    }

    for (i=0; i<n; i++){
        free(w[i]);
    }

    return 9;
}